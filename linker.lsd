OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("/usr/x86_64-pc-linux-gnu/lib64"); SEARCH_DIR("/usr/lib"); SEARCH_DIR("/usr/local/lib"); SEARCH_DIR("/usr/x86_64-pc-linux-gnu/lib");
SECTIONS
{
  /DISCARD/ : {
                  *(.data*) *(.bss) 
                  *(.gnu.warning, .note.*)  *(.gnu_debuglink) 
                  *(.comment) *(.gnu.attributes) *(.eh_frame*)
                  *(.gcc_except*) *(.gnu_extab*) *(.exception*)
                } 
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x010000)); . = SEGMENT_START("text-segment", 0x010000) + SIZEOF_HEADERS;
  .text           :
  {
    *(.text*) *(.stub*)
  }
  .rodata         : { *(.rodata .rodata.*) }

  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */

  .dynamic        : { *(.dynamic) }

  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.*)

   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we do not
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 /1 : 0);
   *(.dynamic)
  }
}
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);